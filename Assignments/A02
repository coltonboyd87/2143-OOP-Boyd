/**
*  Course: CMPS 2143 - OOP
*  Assignment: A02
*  Purpose: Learn to comment effectively.
*
*  @author Colton Boyd 
*  @version 9/4/18
*/

#include <iostream>

using namespace std;

int A[100];


/* Node Implementation for LL 
* Name: Node
*/
struct Node
{
	int x;
	Node *next;
	Node()
	{
		x = -1;
		next = NULL;
	}
	Node(int n)
	{
		x = n;
		next = NULL;
	}
};



/* Class Implementation for List 
* Name: List 
* @Methods: void Push 
*			void Insert 
*			void PrintTail
*			string Print
*/

class List
{
private:
	Node *Head;
	Node *Tail;
	int Size;

public:
	List()
	{
		Head = Tail = NULL;
		Size = 0;
	}


	/*
	* Function Name: void Push 
	* Pushes a new int value while also creating a new node for that value. 
	*
	* @param {int} val: val inserted into node. 
	* @return {void} : return nothing.
	*/
	void Push(int val)
	{
		// allocate new memory and init node
		Node *Temp = new Node(val);

		if (!Head && !Tail)
		{
			Head = Tail = Temp;
		}
		else
		{
			Tail->next = Temp;
			Tail = Temp;
		}
		Size++;
	}


	/*
	* Function Name: void Insert 
	* Pushes a new int value while also creating a new node for that value from
	* the back of the list. 
	* @param {int} val: val inserted into node.
	* @return {void} : return nothing.
	*/
	void Insert(int val)
	{
		// allocate new memory and init node
		Node *Temp = new Node(val);

		// figure out where it goes in the list

		Temp->next = Head;
		Head = Temp;
		if (!Tail)
		{
			Tail = Head;
		}
		Size++;
	}

	/*
	* Function Name: void PrintTail
	* Prints what the tail pointer is pointing to. 
	*
	* @param () nothing passed in. 
	* @return {void} : return nothing.
	*/
	void PrintTail()
	{
		cout << Tail->x << endl;
	}


	/*
	* Function Name: string Print 
	* Converts value in node to a string object and prints that string object. 
	*
	* @param () nothing passed in. 
	* @return {string} : return string object. 
	*/
	string Print()
	{
		Node *Temp = Head;
		string list;

		while (Temp != NULL)
		{
			list += to_string(Temp->x) + "->";
			Temp = Temp->next;
		}

		return list;
	}

	// not implemented 
	int Pop()
	{
		Size--;
		return 0; //
	}

	List operator+(const List &Rhs)
	{
		// Create a new list that will contain both when done
		List NewList;

		// Get a reference to beginning of local list
		Node *Temp = Head;

		// Loop through local list and Push values onto new list
		while (Temp != NULL)
		{
			NewList.Push(Temp->x);
			Temp = Temp->next;
		}

		// Get a reference to head of Rhs
		Temp = Rhs.Head;

		// Same as above, loop and push
		while (Temp != NULL)
		{
			NewList.Push(Temp->x);
			Temp = Temp->next;
		}

		// Return new concatenated version of lists
		return NewList;
	}

	// Implementation of [] operator.  This function returns an
	// int value as if the list were an array.
	int operator[](int index)
	{
		Node *Temp = Head;

		if (index >= Size)
		{
			cout << "Index out of bounds, exiting";
			exit(0);
		}
		else
		{

			for (int i = 0; i < index; i++)
			{
				Temp = Temp->next;
			}
			return Temp->x;
		}
	}

	friend ostream &operator<<(ostream &os, List L)
	{
		os << L.Print();
		return os;
	}
};
//Main function 
int main(int argc, char **argv)
{
	List L1;
	List L2;

	for (int i = 0; i < 25; i++)
	{
		L1.Push(i);
	}

	for (int i = 50; i < 100; i++)
	{
		L2.Push(i);
	}

	//cout << L1 << endl;
	L1.PrintTail();
	L2.PrintTail();

	List L3 = L1 + L2;
	cout << L3 << endl;

	cout << L3[5] << endl;
	return 0;
}
